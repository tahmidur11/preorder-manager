import { isTruthy } from '../environment/utilities.js';
export function waitForInputsToBeReady() {
    return new Promise((resolve) => setTimeout(resolve, 100));
}
export function waitForChange(func, getChangingValue) {
    return new Promise((resolve) => {
        const initialValue = getChangingValue();
        func();
        const interval = setInterval(() => {
            if (getChangingValue() !== initialValue) {
                clearInterval(interval);
                resolve();
            }
        }, 10);
    });
}
function waitFor(func, condition) {
    return new Promise((resolve) => {
        func();
        const interval = setInterval(() => {
            if (condition()) {
                clearInterval(interval);
                resolve();
            }
        }, 10);
    });
}
export function waitForContent(renderInstance, content, func = () => { }) {
    return waitFor(() => func(), () => renderInstance.lastFrame().includes(content));
}
export async function sendInputAndWaitForChange(renderInstance, ...inputs) {
    await waitForChange(() => inputs.forEach((input) => renderInstance.stdin.write(input)), renderInstance.lastFrame);
    // wait for another tick so we give time to react to update caches
    await new Promise((resolve) => setTimeout(resolve, 0));
}
export async function sendInputAndWait(renderInstance, waitTime, ...inputs) {
    inputs.forEach((input) => renderInstance.stdin.write(input));
    await new Promise((resolve) => setTimeout(resolve, waitTime));
}
export async function sendInputAndWaitForContent(renderInstance, content, ...inputs) {
    await waitForContent(renderInstance, content, () => inputs.forEach((input) => renderInstance.stdin.write(input)));
}
export function getLastFrameAfterUnmount(renderInstance) {
    return isTruthy(process.env.CI) ? renderInstance.frames[renderInstance.frames.length - 2] : renderInstance.lastFrame();
}
//# sourceMappingURL=ui.js.map