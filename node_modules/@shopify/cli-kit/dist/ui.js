import { CancelExecution, AbortError, AbortSilentError } from './public/node/error.js';
import { removeFile, fileExists } from './public/node/fs.js';
import { info, completed, content, token, logUpdate, stringifyMessage, debug } from './output.js';
import colors from './public/node/colors.js';
import { relativizePath } from './public/node/path.js';
import { isTerminalInteractive } from './public/node/environment/local.js';
import { run as executorUI } from './ui/executor.js';
import { Listr as OriginalListr } from 'listr2';
import findProcess from 'find-process';
export function newListr(tasks, options) {
    const listr = new OriginalListr(tasks, options);
    return listr;
}
const started = (content, logger) => {
    const message = `${colors.yellow('❯')} ${stringifyMessage(content)}`;
    info(message, logger);
};
const failed = (content, logger) => {
    const message = `${colors.red('✖')} ${stringifyMessage(content)}`;
    info(message, logger);
};
export const task = async ({ title, task }) => {
    let success;
    started(title, logUpdate);
    try {
        const result = await task();
        success = result?.successMessage || title;
    }
    catch (err) {
        failed(title, logUpdate);
        logUpdate.done();
        throw err;
    }
    completed(success, logUpdate);
    logUpdate.done();
};
export const prompt = async (questions) => {
    if (!isTerminalInteractive() && questions.length !== 0) {
        throw new AbortError(content `
The CLI prompted in a non-interactive terminal with the following questions:
${token.json(questions)}
    `);
    }
    const value = {};
    for (const question of questions) {
        if (question.preface) {
            info(question.preface);
        }
        // eslint-disable-next-line no-await-in-loop
        value[question.name] = (await executorUI(question));
    }
    return value;
};
export async function nonEmptyDirectoryPrompt(directory) {
    if (await fileExists(directory)) {
        const options = [
            { name: 'No, don’t delete the files', value: 'abort' },
            { name: 'Yes, delete the files', value: 'overwrite' },
        ];
        const relativeDirectory = relativizePath(directory);
        const questions = {
            type: 'select',
            name: 'value',
            message: `${relativeDirectory} is not an empty directory. Do you want to delete the existing files and continue?`,
            choices: options,
        };
        const choice = await prompt([questions]);
        if (choice.value === 'abort') {
            throw new CancelExecution();
        }
        await removeFile(directory);
    }
}
export async function terminateBlockingPortProcessPrompt(port, stepDescription) {
    const stepDescriptionContent = stepDescription ?? 'current step';
    const processInfo = await findProcess('port', port);
    const formattedProcessName = processInfo && processInfo.length > 0 && processInfo[0]?.name
        ? ` ${content `${token.italic(`(${processInfo[0].name})`)}`.value}`
        : '';
    const options = [
        { name: 'Yes, terminate process in order to log in now', value: 'finish' },
        { name: `No, cancel command and try later`, value: 'cancel' },
    ];
    const choice = await prompt([
        {
            type: 'select',
            name: 'value',
            message: `${stepDescriptionContent} requires a port ${port} that's unavailable because it's running another process${formattedProcessName}. Terminate that process? `,
            choices: options,
        },
    ]);
    return choice.value === 'finish';
}
export const keypress = async () => {
    return new Promise((resolve, reject) => {
        const handler = (buffer) => {
            process.stdin.setRawMode(false);
            process.stdin.pause();
            const bytes = Array.from(buffer);
            if (bytes.length && bytes[0] === 3) {
                debug('Canceled keypress, User pressed CTRL+C');
                reject(new AbortSilentError());
            }
            process.nextTick(resolve);
        };
        process.stdin.resume();
        process.stdin.setRawMode(true);
        process.stdin.once('data', handler);
    });
};
//# sourceMappingURL=ui.js.map